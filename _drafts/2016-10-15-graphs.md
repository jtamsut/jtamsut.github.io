---
layout: post
title: "An Introduction to Graphs"
categories: data structures graphs
---

# Graph Data Structures

Graphs are an increasingly useful data structure. From modeling networks - whether it be a social network, computer network or a network of humans infected with some disease - to determining the shortest path from one geographic locale to another, knowledge of graphs and their associated algorithms can prove to be an invaluable asset to the modern software developer.

This sprint will focus on two main problems dealing with graphs. The first problem discussed will be that of finding the shortest path between two given nodes. We will use a breadth-first traversal algorithm and Djikstra's algorithm to solve this problem. The second problem is that of connecting nodes in a graph in the most efficient manner. In this context the most efficient connections are the ones that minimize the distances between nodes.



I. Some Preliminaries

This section will discuss the requisite information needed to understand the second part of this article.

Definitions

Graphs are a data structure comprised entirely of only two components:

Edges
Nodes or Vertices


Figure 1. A undirected, unweighted graph.

A graph can either be directed or undirected. A undirected graph has unordered vertices. This means that one can traverse an undirected graph in any order. Figure 1 is an undirected graph. A directed graph enforces some ordering with respect to traversal. You can only move from the tail to the head of a directed graph edge arrow. For example, in Figure 2 the only way to go from node a to node c is through nodes b and d. You can think of this as a one-way street.

A graph can also have a weight associated with each edge. This weight is typically an integer. It is simply the cost of traveling from one node to the next node.



Figure 2. A weighted, directed, cyclic graph.

At this point you may be wondering what the difference is between a graph and a tree. A tree can be thought of as a type of graph. The main difference between a graph and a tree is cycles. A cycle is a path on a graph that when followed returns you to where the path began. Figure 2 is a cyclic graph. Trees do not have cycles while graphs sometimes do.

The distance between two nodes in a graph is a measure of how close two nodes are to one another. For an unweighted graph the distance is simply how many edges are between two nodes. For a weighted graph, the distance is the sum of edge weights between two nodes. In Figure 2 the distance from node c to node a is 16 and the distance from node a to node d is 19.

Basic Representations

There are two main ways to represent a graph: an adjacency matrix and an adjacency list.

Adjacency Matrix

An adjacency matrix is a simple table of one's and zero's, each corresponding to an edge. Below is an adjacency matrix of Figure 1. Since node 1 and node 4 are connected the cell corresponding to the 4th row and 1st column and the cell corresponding by the 1st row and 4th column is occupied by a 1. The rest of the matrix is filled out in the same manner.

1	2	3	4
1	0	1	0	1
2	1	0	1	0
3	0	1	0	1
4	1	0	1	0
Adjacency List

The adjacency representation utilizes a list to store edges in a graph. In this representation each node has associated with it, a list of the edges it is connected to. For example an adjacency list representation of the graph in Figure 1 would look like this in pseudocode:




Relative Efficiencies of Each Representation

Using either an adjacency list or an adjacency matrix has its advantages and drawbacks. Using an adjacency matrix requires the creation of an n-dimensional array. This array occupies a fixed space in memory. If the graph in question is a sparse graph, or a graph that has many more nodes than edges, then using an adjacency matrix is not an efficient use of memory. The matrix will be composed mostly of 0's and therefore contain a large amount of not useful information stored in memory. A better choice is to use an adjacency list which only stores nodes that are connected. On the other hand, if a graph is densely populated (i.e., the graph has approximately an equal amount of nodes and edges), or if one needs to quickly check if an edge exists, then an adjacency matrix is the prefered method. This is because search in an array is O(n) while lookup can be done in constant time.



II. Graph Algorithms

This section will discuss three different graph algorithms. These three algorithms are similar to one another and are examples of greedy algorithms. A greedy algorithm is an algorithm that chooses the locally optimal choice at each stage to get the globally optimal solution. This is a general class of algorithms. Why these three algorithms can be thought of as greedy will become clear later.

Finding the Shortest Path

The shortest path problem is as follows: given a graph and a starting node, find the shortest path from that node to every other node. We will discuss two algorithms that accomplish this task: breadth-first search and Dijkstra's search algorithm.

Breadth-First Search

A breadth-first search algorithm is initially provided a starting node. We will call this initial node the source node. The central idea behind breadth-first graph traversal is that the algorithm works by first visiting all the nodes that are connected to the source node before it traverses any other nodes. This logic is repeated for the nodes that are connected to the source node and so on, until all nodes are visited.




To implement breadth-free search you can uses a queue. Here is some pseudocode for the breadth-first search algorithm.

function breadth-first(graph, source node)
    put the source node onto the queue
    while queue is not empty
        dequeue
        visit that the dequeued node
        put the children of the dequeued node in the queue
Now watch this video explaining breadth-first graph traversal. Note: Start watching the video at the 4:38 mark.

Dijkstra's shortest path algorithm

Dijkstra's shortest path algorithm is another algorithm for computing the shortest path between nodes in a graph. It works in a similar fashion to breadth-first search. The difference between Dijsktra's and breadth-first search is that breadth-first search does not work on a graph that has edge weights that are not 1. Dijkstra's algorithm can work for weighted graphs where the edge weights are any number greater than 0.

Priority Queue Review

Instead of using a normal queue as in breadth-first search, Djikstra's algorithm utilizes a priority queue. A priority queue is a queue in which each element in the queue is given a key that denotes the priority or order in which that element is positioned in the queue. One can think of elements with a higher priority being removed from the queue before elements with a lower priority.
Dijkstra's algorithm finds the shortest path between one node and every other node on a directed (or undirected), weighted graph. The weights on each edge must be a positive integer in order for Djikstra's algorithm to work. Generally speaking Djikstra's algorithm works as follows:

Djikstra(graph, source node)
    update the priority queue with the source node*
    while you have not visited all nodes in the graph
        dequeue the priority queue
        visit the dequeued node
        update the priority queue


Note: Whenever you add a node to the priority queue you are updating the priorities to be equal to the distances from the current node to its neighbors.



Figure 5. A weighted, directed graph. The red node is the source node.

For a great visual explanation of Djikstra's algorithm check out this link and this link.

Minimum Spanning Trees

A minimum spanning tree is a tree representation of a graph. Algorithms that convert a graph to its minimum spanning tree - such as Prim's algorithm - remove the cycles from a graph and connect the nodes in a way so as to minimize edge weights.

Prim's Algorithm

Prim's algorithm works in a similar way to Djikstra's algorithm. Broadly speaking, this algorithm works by building a tree one node at a time. The algorithm starts from a randomly chosen starting node and moves through the array choosing the cheapest possible connection at each stage.


Figure 6. The minimum spanning tree of a graph.

For an intuitive explanation of Prim's algorithm see this link.
